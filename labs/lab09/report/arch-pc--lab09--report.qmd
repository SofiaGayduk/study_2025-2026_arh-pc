---
## Author
author:
  name: Гайдук Софья Сергеевна
  degrees: DSc
  orcid: 0000-0002-0877-7063
  email: 1032253645@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Отчёт по лабораторной работе №9"
subtitle: "дисциплина: Архитектура компьютера"
license: "CC BY"
---

# Цель работы

Приобретение навыков написания программ с использованием подпрограмм. Знакомство с методами отладки при помощи GDB и его основными возможностями.

# Выполнение лабораторной работы

Создадим каталог для выполнения лабораторной работы №9, перейдем в него, создадим файл lab09-1.asm и проверим его наличие ([рис. @fig-001]).

![image1](image/image1.jpg){#fig-001 width=70%}

Введем в файл lab09-1.asm текст программы из листинга 9.1. Создадим исполняемый
файл и проверим его работу ([рис. @fig-002, @fig-003]).

![image2](image/image2.jpg){#fig-002 width=70%}


![image3](image/image3.jpg){#fig-003 width=70%}

Изменим текст программы, добавив подпрограмму _subcalcul в подпрограмму _calcul,
для вычисления выражения f(g(x)), где f(x)=2x+7 (выполняется в _calcul), g(x)=3x-1 (выполняется в _subcalcul). Создадим исполняемый файл и проверим его работу ([рис. @fig-004, @fig-005]). 

![image4](image/image4.jpg){#fig-004 width=70%}


![image5](image/image5.jpg){#fig-005 width=70%}

Создайте файл lab09-2.asm с текстом программы из Листинга 9.2 ([рис. @fig-006, @fig-007]). 

![image6](image/image6.jpg){#fig-006 width=70%}


![image7](image/image7.jpg){#fig-007 width=70%}

Создадим исполняемый файл и проверим его работу ([рис. @fig-008]). 

![image8](image/image8.jpg){#fig-008 width=70%}

Получим исполняемый файл для работы с GDB, в исполняемый файл необходимо добавить отладочную информацию. Трансляцию программ необходимо проводить с ключом ‘-g’. Загрузим исполняемый файл в отладчик gdb ([рис. @fig-009]). 

![image9](image/image9.jpg){#fig-009 width=70%}

Проверим работу программы, запустив ее в оболочке GDB с помощью команды run ([рис. @fig-010]). 

![image10](image/image10.jpg){#fig-010 width=70%}

Для более подробного анализа программы установим брейкпоинт на метку _start, с которой начинается выполнение любой ассемблерной программы, и запустим её ([рис. @fig-011]). 

![image11](image/image11.jpg){#fig-011 width=70%}

Посмотрим дисассимилированный код программы с помощью команды disassemble начиная с метки _start ([рис. @fig-012]). 

![image12](image/image12.jpg){#fig-012 width=70%}

Переключимся на отображение команд с Intel’овским синтаксисом, введя команду set disassembly-flavor intel ([рис. @fig-013]). 

![image13](image/image13.jpg){#fig-013 width=70%}

Различия отображения синтаксиса машинных команд в режимах ATT и Intel заключаются в обозначении регистров % и значений $, которые в GDB используются по умолчанию. 

Включим режим псевдографики для более удобного анализа программы ([рис. @fig-014, @fig-015]). 

![image14](image/image14.jpg){#fig-014 width=70%}


![image15](image/image15.jpg){#fig-015 width=70%}

На предыдущих шагах была установлена точка останова по имени метки (_start). Проверим это с помощью команды info breakpoints (i b) ([рис. @fig-016, @fig-017]). 

![image16](image/image16.jpg){#fig-016 width=70%}


![image17](image/image17.jpg){#fig-017 width=70%}

Определим адрес предпоследней инструкции (mov ebx,0x0) и установите точку останова. Посмотрите информацию о всех установленных точках останова с помощью i b ([рис. @fig-018]). 

![image18](image/image18.jpg){#fig-018 width=70%}

Выполним 5 инструкций с помощью команды stepi (si) и проследим за изменением значений регистров ([рис. @fig-019, @fig-020, @fig-021, @fig-022, @fig-023]). 

![image19](image/image19.jpg){#fig-019 width=70%}


![image20](image/image20.jpg){#fig-020 width=70%}


![image21](image/image21.jpg){#fig-021 width=70%}


![image22](image/image22.jpg){#fig-022 width=70%}


![image23](image/image23.jpg){#fig-023 width=70%}

Изменяются значения регистров ebx, ecx, edx, на eax мы заканчиваем выполнение инструкций. 

Посмотреть содержимое регистров также можно с помощью команды info registers (i r) ([рис. @fig-024, @fig-025]). 

![image24](image/image24.jpg){#fig-024 width=70%}


![image25](image/image25.jpg){#fig-025 width=70%}

Посмотрим значение переменной msg1 по имени ([рис. @fig-026]). 

![image26](image/image26.jpg){#fig-026 width=70%}

Посмотрим значение переменной msg2 по адресу. Посмотрим инструкцию mov ecx,msg2 которая записывает в регистр ecx адрес перемененной msg2 (0x804a008) ([рис. @fig-027]). 

![image27](image/image27.jpg){#fig-027 width=70%}

Изменим первый символ переменной msg1 ([рис. @fig-028]). 

![image28](image/image28.jpg){#fig-028 width=70%}

Изменим первый символ переменной msg2 ([рис. @fig-029]). 

![image29](image/image29.jpg){#fig-029 width=70%}

Изменим второй символ переменной msg1 и первый и четвертый символ переменной msg2 ([рис. @fig-030]). 

![image30](image/image30.jpg){#fig-030 width=70%}

Выведем в различных форматах (в шестнадцатеричном формате, в двоичном формате и
в символьном виде) значение регистра edx ([рис. @fig-031]). 

![image31](image/image31.jpg){#fig-031 width=70%}

С помощью команды set изменим значение регистра ebx ([рис. @fig-032, @fig-033]). 

![image32](image/image32.jpg){#fig-032 width=70%}


![image33](image/image33.jpg){#fig-033 width=70%}

Разница вывода команд p/s $ebx в том, что '2' мы передаем строку, код которой преобразуем в символьной вид, а 2 мы передаем число, которое также преобразуем в символьной вид.

Завершим выполнение программы с помощью команды continue (c) ([рис. @fig-034]). 

![image34](image/image34.jpg){#fig-034 width=70%}

И выйдем из GDB с помощью команды quit (q) ([рис. @fig-035]). 

![image35](image/image35.jpg){#fig-035 width=70%}

Скопируем файл lab8-2.asm, созданный при выполнении лабораторной работы №8,
с программой выводящей на экран аргументы командной строки (Листинг 8.2) в файл с
именем lab09-3.asm ([рис. @fig-036]). 

![image36](image/image36.jpg){#fig-036 width=70%}

Создаим исполняемый файл ([рис. @fig-037]). 

![image37](image/image37.jpg){#fig-037 width=70%}

Загрузим исполняемый файл в отладчик, указав аргументы ([рис. @fig-038]). 

![image38](image/image38.jpg){#fig-038 width=70%}

Исследуем расположение аргументов командной строки в стеке после запуска программы с помощью gdb. Для начала установим точку останова перед первой инструкцией в программе и запустим ее ([рис. @fig-039]). 

![image39](image/image39.jpg){#fig-039 width=70%}

Адрес вершины стека храниться в регистре esp и по этому адресу располагается число равное количеству аргументов командной строки (включая имя программы) ([рис. @fig-040]). 

![image40](image/image40.jpg){#fig-040 width=70%}

Число аргументов равно 5 - это имя и четыре аргумента. 

Посмотрите остальные позиции стека ([рис. @fig-041]). 

![image41](image/image41.jpg){#fig-041 width=70%}

Шаг изменения адреса равен 4 ([esp+4], [esp+8], [esp+12] и т.д.) потому, что в esp находится 32-битной системе, где размер одного аргумента равен 4 байта.  

# Задания для самоятоятельной работы 

Номер 1. 

Преобразуем программу из лабораторной работы №8 (Задание №1 для самостоятельной работы), реализовав вычисление значения функции f(x) как подпрограмму. Скопируем файл из лабораторной работы №8 с названием lab09-4.asm. Создадим исполняемый файл и проверим его работу ([рис. @fig-042, @fig-043, @fig-044]). 

![image42](image/image42.jpg){#fig-042 width=70%}


![image43](image/image43.jpg){#fig-043 width=70%}


![image44](image/image44.jpg){#fig-044 width=70%}

Номер 2. 

Создадим файл с названием lab09-5.asm. Проверьте порграмму. С помощью отладчика GDB, анализируя изменения значений регистров ([рис. @fig-045, @fig-046, @fig-047, @fig-048, @fig-049, @fig-050]). 

![image45](image/image45.jpg){#fig-045 width=70%}


![image46](image/image46.jpg){#fig-046 width=70%}


![image47](image/image47.jpg){#fig-047 width=70%}


![image48](image/image48.jpg){#fig-048 width=70%}


![image49](image/image49.jpg){#fig-049 width=70%}


![image50](image/image50.jpg){#fig-050 width=70%}

Определим ошибку и исправим ее. Мы видим, что значения изначально записываются в регистр ebx, а умножение происходит в регистре eax. Далее ebx прибаляем 5 и выводится результат ebx. Исправим это. После суммы eax и ebx перезапишем ее в eax. Прибавляем 5 в eax, и вывод в eax ([рис. @fig-051, @fig-052, @fig-053, @fig-054, @fig-055]). 

![image51](image/image51.jpg){#fig-051 width=70%}


![image52](image/image52.jpg){#fig-052 width=70%}


![image53](image/image53.jpg){#fig-053 width=70%}


![image54](image/image54.jpg){#fig-054 width=70%}


![image55](image/image55.jpg){#fig-055 width=70%}

Теперь результат правильный. 

Создадим исполняемый файл и проверим его работу ([рис. @fig-056, @fig-057]). 

![image56](image/image56.jpg){#fig-056 width=70%}


![image57](image/image57.jpg){#fig-057 width=70%}

Отправим файлы на Github ([рис. @fig-058]). 

![image58](image/image58.jpg){#fig-058 width=70%}

# Выводы

Мы приобрели навыки написания программ с использованием подпрограмм. Ознакомились с методами отладки при помощи GDB и его основными возможностями.

::: {#refs}
:::
